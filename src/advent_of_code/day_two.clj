(ns advent-of-code.day-two
  (:require [clojure.core.match :refer [match]]
            [clojure.string :as str]))

(def input "RUDULRLLUULRURDDRRUDURULLLDRLRLUDDLUDUDDUDRRDUDULDUUULLRULLRLDDLDLDDRLRRRRUDLLDDUULDRLLUDDRRUURLULRRRDLLURRUUDURUDDURLUDDDLUDDUUDUURUDLRDRDRLRDRLDRUDRUUDLRDDRRURDDLRDDRRURDUDDLULLUDRURURRRLRRUDUULULULRRLDLUDUURRLLRUDLLDRDDLRRRULRUDLULDDLLLULDLRUDLLLLRDDLRDRLDRLLRDRRDLRDULULRLLLDRUDRRRUULRUULDRURLUDRURRDLLDLRDLDDDDRRLUDLRRLUUUURDRDDLRRURURRDUULLRLURLURUDDDRDURDUUDRLRLRRLDDLDLDLDDDUDDULURLDDLLRLRRDULUDDLULRLUDDLDLRULUUUDRLDRUDURLUDDRLLRUULDLRRRRDLLLLURULLRDRRUDLUULRRDLLRLRLUDLDDULLDLLRDLDLL
LLUUUUUUDUDRLRDRDLDURRRLLRRLRURLLUURRLLUDUDLULUURUUURDLUDLDDLULLRDLRUULDLRDUDURLLDDUDUDULLUDDUULLLUULRRRLULRURRDLRUDUDDURRRDRUURDURLLULLRULLDRUULLURLDRDUUDDDDDDRRLDRLRRRLULDDUURRLLLLDRURLURDRDRDURUDUURRDUDUDRLLUUDDRLUDDDRDLDLRLDRURRDLLRULDRLLURURRLUULLRLRRURDDRDRUUURUURUUUDLLRRLUDRLDLRLURLDLUDDUDDDLDUDRRLDLRURULRLLRDUULURRRULDLLLRLDDDUURRRRDULLRURRLULULDLRRUDUDDLRUURDLDUDDUDRRDLRRRDUDUUUDLLDDDDLURLURRRUUULLLULRRLLLLLLULDUUDLRUDRRDLRDUUDUDLLRLDLLRUURDUUURUUUDDLLUUDLULDURLULULUUUDRUDULLURRULRULLRDLDDU
RLUUURULLDLRLDUDRDURRDUURLLUDDDUULRRRLRLURDDRUULUDULDUUDDDDUDDDDRUDDLDUUDRUDLRRRLLRDDLLLRLLRUULRUULDDRURRLURRLRLULDDRRRDDURDDRDRDULRUDRUUDULRLLULDLRLLDRULRDDRRDDUDLRLLUDRDRRRLUDULRDLRDDURRUUDDRRUDURRUUUDDRRDUDURLUUDUDUURDDDLURLULLUULULURUDUUDRUDULLUUULURDLDUULLDDLLDULRLRLRDUUURUUDLRLDURUDRLDULLUDLDLLRDUURRDUDURLUUUDLLRRULRLULRLDLLURDURRULRLLRRDUDLLRDRRRRDLUUDRUUUDDLRLUDDDDDDRURRRUUURRDLLRURLDDLLDLRRLLLDRRULRRUDLDRDDRRLULURLLUURURURRRRUUUUURUDURLRLLLULULDLLDLRDRRULUDUDRDRRDRDRRDUDLLLRUDRUDDDULRULRRRDRLRUUUURUDURDUUULLULRUDDULDUUDLDURRD
ULRULDDLDLULLLRRRLRUDDDDDLLDDUDLRRDULUUDRDLRRURDRRLUULRURUDRRULDLLLUDRUUDULULUDDRUDDDRDURRRDRDUUURLRDULUDRDRLDRUDDLLLDRRULUDLUDLDLLRRUDUULULDLDLLUURDLDDLLUUDURLURLLLDRDLDRRLRULUURRDRULRUUURULRRUDDDDLLDLDDLLRRLRRRRDUUDUDLDRDRRURDLRURULDLRDLLLLRUDRLLRDLRLRDURDRUDURRRLRDRDLLRLUDDDDRLRLLDUURRURLUURUULUDLUURDRRUDDLUDUDDDURRDRUDRLRULDULUUUUUUDDUDRUDUUURUDRRDLUDLUUDUULUDURDLDDDLLURRURUUDUDDRRDRLLULULDRLRURRDDDRDUUURDDDRULUDRDDLDURRLDDDLRRRLDDRDURULDLUDLLLURLURRLRRULDLLDDUDRRULDRRRRLURRUULRRRUDLURDLLDLLDULUUDRRLDLLLDRLRUDLUULDLDRUDUDURDRUDRDDDLRLULLUR
LRLUUURRLRRRRRUURRLLULRLULLDLUDLUDRDDRLDLRLULLURDURLURDLLRLDUUDDURRRRLDLLRULLRLDLLUUDRLDDLLDRULDRLLRURDLRURRUDLULLRURDLURRURUDULLDRLLUUULUDRURRUUDUDULUUULRLDDULDRDLUDDUDDDLRURULLDLLLRLLUURDLRUDLLLLDLLRLRUUUDDRUUUUDLDLRDDURLDURUULLLUUDLLLLDULRRRLLDLDRRDRLUDRUDURLLUDLRLLUDUDRDDDRDLRDLRULUULDRLUDLRLDUURLRRLUDDDUUDDDUDRLDLDUDLURUULLDDDURUUULRLUDLDURUUDRDRURUDDUURDUUUDLLDLDLDURUURLLLLRURUURURULRULLRUDLRRUUUUUDRRLLRDDUURDRDRDDDUDRLURDRRRUDLLLDURDLUUDLLUDDULUUDLDUUULLDRDLRURUURRDURRDLURRRRLLUUULRDULDDLDUURRDLDLLULRRLLUDLDUDLUUL")

;; Really just a whole bunch of dispatch, also I bet that the part-two will want
;; me to change this, so core match!

(defn next-button [number direction]
  (match [number direction]
         [1 \U] 1
         [1 \D] 4
         [1 \L] 1
         [1 \R] 2
         [2 \U] 2
         [2 \D] 5
         [2 \L] 1
         [2 \R] 3
         [3 \U] 3
         [3 \D] 6
         [3 \L] 2
         [3 \R] 3
         [4 \U] 1
         [4 \D] 7
         [4 \L] 4
         [4 \R] 5
         [5 \U] 2
         [5 \D] 8
         [5 \L] 4
         [5 \R] 6
         [6 \U] 3
         [6 \D] 9
         [6 \L] 5
         [6 \R] 6
         [7 \U] 4
         [7 \D] 7
         [7 \L] 7
         [7 \R] 8
         [8 \U] 5
         [8 \D] 8
         [8 \L] 7
         [8 \R] 9
         [9 \U] 6
         [9 \D] 9
         [9 \L] 8
         [9 \R] 9))

(defn find-button [number directions]
  (reduce (fn [acc direction]
            (next-button acc direction)) number directions))

(defn find-combination [input]
  (let [lines (str/split-lines input)]
    (rest (reduce (fn [combo line]
                    (conj combo (find-button (last combo) line)))
                  [5] lines))))


;; Part two!


;; Whew, glad I didn't take numerical shortcuts.
;; I am gonna use the else condition to type less

(defn next-button-part-two [number direction]
  (match [number direction]
         [1 \D] 3
         [2 \R] 3
         [2 \D] 6
         [3 \U] 1
         [3 \D] 7
         [3 \L] 2
         [3 \R] 4
         [4 \L] 3
         [4 \D] 8
         [5 \R] 6
         [6 \U] 2
         [6 \D] 'A
         [6 \L] 5
         [6 \R] 7
         [7 \U] 3
         [7 \D] 'B
         [7 \L] 6
         [7 \R] 8
         [8 \U] 4
         [8 \D] 'C
         [8 \L] 7
         [8 \R] 9
         [9 \L] 8
         ['A \R] 'B
         ['A \U] 6
         ['B \U] 7
         ['B \L] 'A
         ['B \R] 'C
         ['B \D] 'D
         ['C \U] 8
         ['C \L] 'B
         ['D \U] 'B
         :else number))


(defn find-button-part-two [number directions]
  (reduce (fn [acc direction]
            (next-button-part-two acc direction)) number directions))

(defn find-combination-part-two [input]
  (let [lines (str/split-lines input)]
    (rest (reduce (fn [combo line]
                    (conj combo (find-button-part-two (last combo) line)))
                  [5] lines))))
